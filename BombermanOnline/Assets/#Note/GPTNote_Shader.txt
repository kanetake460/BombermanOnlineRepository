【シェーダー】
シェーダーは、3Dレンダリングにおいて、頂点データやピクセルデータの処理方法を
定義するプログラムです。主に次の2つの主要な種類があります：

〇頂点シェーダー：頂点データを処理します。
	位置変換、法線計算、テクスチャ座標の変換などが行われます。
〇ピクセルシェーダー（フラグメントシェーダー）：ピクセルデータを処理します。
	色や光の計算、テクスチャの適用などが行われます。


【CGPROGRAM】
CGPROGRAMは、パス内でシェーダーコードを記述するためのブロックです。このブロック内には、頂点シェーダーとピクセルシェーダーを定義します。

<特徴>
HLSL互換：CGPROGRAMはHLSLと非常に似ており、DirectX用に設計されたHLSLコードをほぼそのまま利用できます。
マルチプラットフォーム：Unityはマルチプラットフォームをサポートしているため、CGPROGRAMで記述されたシェーダーは多くの異なるプラットフォームで動作します。
高性能：GPUを活用した高速な処理が可能です。


<CGPROGRAMの構造>
★CGPROGRAM - ENDCG：この間にCGPROGRAMのコードが記述されます。
	#pragma vertex vert / #pragma fragment frag：頂点シェーダーとピクセルシェーダーのエントリーポイントを指定します。
	構造体の定義：頂点データや出力データの構造体を定義します。
	シェーダー関数：頂点シェーダー関数 vert とピクセルシェーダー関数 frag を定義します。

〇プラグマディレクティブ
	頂点シェーダーとピクセルシェーダーのエントリーポイントを指定する。

〇シェーダーコードのインクルード
	共通コードを含めるためのインクルード文（例：#include "UnityCG.cginc"）。

〇構造体の定義
	頂点データやフラグメントデータの構造を定義する。

〇シェーダー関数の定義
頂点シェーダー（vert）とピクセルシェーダー（frag）を定義する。

<例>

    CGPROGRAM
    #pragma vertex vert 			// 頂点シェーダーのエントリーポイント
    #pragma fragment frag 			// ピクセルシェーダーのエントリーポイント
    								/*
								    エントリーポイントとは、
								    プログラムやシェーダーの実行が開始される
								    関数のことを指します。
								    ★このディレクティブを使うことで、どの関数が
								    頂点シェーダーとして実行されるかを
								    Unityに指示をする。
								    シェーダーにおいては、特定のステージ
								    （例えば、頂点シェーダーやピクセルシェーダー）
								    で実行される最初の関数です。
									 */

    #include "UnityCG.cginc"		 // 共通ユーティリティコードのインクルード
								    /* 
								    #include "UnityCG.cginc"を使用することで、
								    Unityが提供する多くの便利な関数や定義を利用することができます。
								    これにより、シェーダーの開発が簡素化され、再利用性が向上します。
								    具体的には、座標変換や照明計算、テクスチャサンプリングなど、
								    多くの基本的な操作を簡単に行うことができます。
								    */

    // 頂点データの構造体
    // 頂点の入力データを定義します。
    // application data type の略でアプリケーションからシェーダーに渡されるデータを示している。
    // 通常は、頂点シェーダーに入力される頂点データを表します。
    // これには、頂点の位置や法線、テクスチャ座標などの情報が含まれます。
    struct appdata_t {
        float4 vertex : POSITION;			// 頂点の位置
        float2 uv : TEXCOORD0;				// テクスチャ座標
    };

    // 頂点シェーダーの出力データの構造体
    // v2fはvertex to fragment の略で、頂点シェーダーから
    // ピクセルシェーダーに渡されるデータを示している。
    // 頂点シェーダーの出力データを定義します。
    // 頂点シェーダーからピクセルシェーダーにデータを渡す際に使用される。
    // この構造体には、変換された頂点の位置や法線、テクスチャ座標などの情報が含まれます。
    struct v2f {
        float2 uv : TEXCOORD0;				// テクスチャ座標（ピクセルシェーダー）
        float4 vertex : SV_POSITION;		// クリップ空間座標
    };

    // テクスチャサンプラーの宣言
    // これにより、テクスチャのピクセル値をシェーダー内でサンプリングして利用したり、
	// シェーダーからテクスチャへの書き込みを行ったりすることが可能になります。
    sampler2D _MainTex;

    // 頂点シェーダー
    v2f vert (appdata_t v) {
        v2f o;
        o.vertex = UnityObjectToClipPos(v.vertex); 		// 頂点をクリップ空間に変換
        o.uv = v.uv; 									// テクスチャ座標を渡す
        return o;
    }

    // ピクセルシェーダー
    half4 frag (v2f i) : SV_Target {
        half4 col = tex2D(_MainTex, i.uv); 				// テクスチャをサンプリング
        return col; 									// サンプリング結果を返す
    }
    ENDCG
===================================================================================
セマンティクスの役割
頂点シェーダー入力：

POSITION：頂点の位置データを表します。
NORMAL：頂点の法線ベクトルを表します。
TEXCOORD：テクスチャ座標を表します。
頂点シェーダー出力/ピクセルシェーダー入力：

SV_POSITION：システムセマンティクスで、ピクセルシェーダーに渡される位置データを示します。
COLOR：色データを示します。
TEXCOORD：テクスチャ座標を示します。
ピクセルシェーダー出力：

SV_TARGET：最終的にレンダリングターゲットに出力される色データを示します。
セマンティクスは、シェーダーがどのようにデータを受け取り、処理し、出力するかを理解するために非常に重要です。
===============================================================================
【ブレンドモード】
・レンダリングパイプラインにおける画面出力前の最後の処理
    （フラグメントシェーダーから出力した色をどう扱うか）

〇書き方
Blend [SrcFactor] [DstFactor]

〇計算式
最終的に出力される色
フラグメントシェーダの出力 * SrcFactor +  すでに画面に描画されている色 * DstFactor

〇SrcFactorとDstFactorに利用できるもの(OneMinusがつくと、その値から1を引く)
・One
・Zero
・[OneMinus]SrcColor
・[OneMinus]SrcAlpha
・[OneMinus]DstColor
・[OneMinus]DstAlpha

〇よく使う組み合わせ
・Blend SrcAlpha OneMinusSrcAlpha：アルファブレンド(Alpha Blended)
    不透明度

・Blend One One：加算合成(Addtive)
    そのまま足す
    明るい表現になるのでエフェクトでよく使う

・Blend OneMinusDstColor One：ソフト加算合成(Soft Addtive)
    眩しくなりすぎないように加算の度合いを調整したもの
    OneMinusDstColorで既に描画されている色の明るさを考慮して加算することができる

・Blend DstColor Zero：乗算合成(Multiplicative)
    単純に色をかけ合わせる
    もともと描画されていた色に馴染ませる効果

・Blend DstColor SrcColor：乗算合成した者同士を足す(2xMultiplicative)
    通常の乗算合成は暗くなる
    明るさを維持してかけ合わせる
===================================================================================
【Zテスト】
オブジェクトは手前にあるものを先に、奥にあるものを後で描画する
    →奥にあるオブジェクトが画面に映ってしまうことを防ぐ

〇書き方
SubuShader内に記述することで変更可能
何も指定しなかったら「LEqual」(Less or Equal)値が小さいか等しかったら
つまり、描画しようとしているピクセルの方が等しいか、近い場合は成功

【レンダーキュー】
数値が「大きい」物が後から描画される

前後関係に合わせてマテリアルの設定をいじるのは大変なのでシェーダ側でデフォルト値を変更できる
Tags
{
    "Queue" = "Transparent"
}
オプションを追加しなかったら「Geometry」で2000になる
「Transparent」は3000

しかし、このシェーダを使うオブジェクトがすべて3000になっては駄目じゃないか？
A．2500までと、2501以降では挙動が違う
    2500までは、全く同じレンダーキューの値なら、手前から奥にソート
    2501以降は、全く同じレンダーキューの値なら、奥から手前にソート

自分の作ったシェーダーを他の人が使うことを想定するならシェーダの実装で解消したい
unityのビルトインシェーダーに含まれる半透明シェーダーでは「Zバッファの書き込みをしない」という風になっている
    →ZWrite Off
しかし、ソート順の影響は残る、見えてほしくないところまで見える、という問題がある

===================================================================================
【質問】
〇この処理は何か
	#pragma vertex vert
	
〇構造体名は何を表している
	appdata_t、v2f
	
×何を宣言している、これによって何ができる
	// テクスチャサンプラーの宣言
	sampler2D _MainTex;
	
	A.これにより、テクスチャのピクセル値をシェーダー内でサンプリングして利用したり、
	シェーダーからテクスチャへの書き込みを行ったりすることが可能になります。

×half4 とは

	A.通常RGBA色情報やベクトル情報などを表す際に使用されます。

× これらの関数で行っている具体的な説明
   // 頂点シェーダー
    v2f vert (appdata_t v) {
        v2f o;
        o.vertex = UnityObjectToClipPos(v.vertex); 		// 頂点をクリップ空間に変換
        o.uv = v.uv; 									// テクスチャ座標を渡す
        return o;
    }

    // ピクセルシェーダー
    half4 frag (v2f i) : SV_Target {
        half4 col = tex2D(_MainTex, i.uv); 				// テクスチャをサンプリング
        return col;


